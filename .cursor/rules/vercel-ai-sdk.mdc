# Vercel AI SDK for Flashcard Generation

This project uses the **Vercel AI SDK** (`ai` npm package) to integrate OpenAI for AI-powered flashcard generation features.

## Installation

The Vercel AI SDK is installed via npm:

```bash
npm install ai @ai-sdk/openai zod
```

## Core Concepts

- **`generateText`**: Generate text or structured data from AI models
- **`Output.object()`**: Generate structured, type-safe outputs using Zod schemas
- **OpenAI Provider**: Uses `@ai-sdk/openai` package for OpenAI model access
- **Zod Integration**: Schema validation ensures type-safe AI responses

## Configuration

OpenAI API key must be configured in environment variables:

```bash
# .env.local
OPENAI_API_KEY=sk-...
```

## Generating Structured Flashcards

### Basic Pattern - Generate Array of Flashcards

Use `Output.object()` with Zod schemas to generate structured flashcard data:

```typescript
import { generateText, Output } from 'ai';
import { openai } from '@ai-sdk/openai';
import { z } from 'zod';

const { output } = await generateText({
  model: openai('gpt-4o'),
  output: Output.object({
    schema: z.object({
      cards: z.array(
        z.object({
          front: z.string(),
          back: z.string(),
        })
      ),
    }),
  }),
  prompt: 'Generate 5 flashcards about React hooks with questions on the front and answers on the back.',
});

// output.cards is typed as: Array<{ front: string; back: string }>
console.log(output.cards);
// [
//   { front: "What is useState?", back: "useState is a React Hook..." },
//   { front: "What is useEffect?", back: "useEffect is a React Hook..." },
//   ...
// ]
```

### Advanced Pattern - With Metadata

Generate flashcards with additional metadata like difficulty, tags, or categories:

```typescript
import { generateText, Output } from 'ai';
import { openai } from '@ai-sdk/openai';
import { z } from 'zod';

const { output } = await generateText({
  model: openai('gpt-4o'),
  output: Output.object({
    schema: z.object({
      cards: z.array(
        z.object({
          front: z.string().describe('The question or prompt'),
          back: z.string().describe('The answer or explanation'),
          difficulty: z.enum(['easy', 'medium', 'hard']).optional(),
          tags: z.array(z.string()).optional(),
        })
      ),
    }),
  }),
  prompt: `Generate 10 flashcards about JavaScript async/await.
Include difficulty level and relevant tags for each card.`,
});

// Type-safe access
output.cards.forEach((card) => {
  console.log(`Q: ${card.front}`);
  console.log(`A: ${card.back}`);
  console.log(`Difficulty: ${card.difficulty}`);
  console.log(`Tags: ${card.tags?.join(', ')}`);
});
```

### Dynamic Number of Cards

Allow users to specify how many cards to generate:

```typescript
import { generateText, Output } from 'ai';
import { openai } from '@ai-sdk/openai';
import { z } from 'zod';

async function generateFlashcards(topic: string, count: number) {
  const { output } = await generateText({
    model: openai('gpt-4o'),
    output: Output.object({
      schema: z.object({
        cards: z.array(
          z.object({
            front: z.string(),
            back: z.string(),
          })
        ).length(count), // Enforce exact count
      }),
    }),
    prompt: `Generate exactly ${count} flashcards about ${topic}.
Each card should have a question on the front and a detailed answer on the back.`,
  });

  return output.cards;
}

// Usage
const cards = await generateFlashcards('TypeScript generics', 7);
console.log(`Generated ${cards.length} cards`); // Always 7
```

## Integration with Server Actions

Follow the project's Server Action patterns when implementing AI flashcard generation:

### Server Action Pattern

```typescript
// app/actions/ai-actions.ts
'use server';

import { auth } from '@clerk/nextjs/server';
import { z } from 'zod';
import { generateText, Output } from 'ai';
import { openai } from '@ai-sdk/openai';
import { createCard } from '@/db/queries/cards';

// Input validation schema
const generateFlashcardsSchema = z.object({
  deckId: z.number(),
  topic: z.string().min(1).max(500),
  count: z.number().min(1).max(20),
});

type GenerateFlashcardsInput = z.infer<typeof generateFlashcardsSchema>;

export async function generateFlashcardsAction(input: GenerateFlashcardsInput) {
  // ✅ Step 1: Validate with Zod
  const validated = generateFlashcardsSchema.parse(input);

  // ✅ Step 2: Authenticate
  const { userId } = await auth();
  if (!userId) throw new Error('Unauthorized');

  // ✅ Step 3: Generate flashcards with AI
  const { output } = await generateText({
    model: openai('gpt-4o'),
    output: Output.object({
      schema: z.object({
        cards: z.array(
          z.object({
            front: z.string(),
            back: z.string(),
          })
        ),
      }),
    }),
    prompt: `Generate exactly ${validated.count} flashcards about ${validated.topic}.
Each card should have a clear question on the front and a detailed answer on the back.
Make the cards educational and suitable for studying.`,
  });

  // ✅ Step 4: Save cards to database
  const savedCards = [];
  for (const card of output.cards) {
    const savedCard = await createCard(userId, validated.deckId, {
      front: card.front,
      back: card.back,
    });
    savedCards.push(savedCard);
  }

  return {
    success: true,
    cardsGenerated: savedCards.length,
    cards: savedCards,
  };
}
```

### Client Component Calling Server Action

```typescript
// app/decks/[deckId]/generate-cards-dialog.tsx
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { generateFlashcardsAction } from '@/app/actions/ai-actions';

export function GenerateCardsDialog({ deckId }: { deckId: number }) {
  const [topic, setTopic] = useState('');
  const [count, setCount] = useState(5);
  const [isGenerating, setIsGenerating] = useState(false);

  const handleGenerate = async () => {
    setIsGenerating(true);
    try {
      const result = await generateFlashcardsAction({
        deckId,
        topic,
        count,
      });
      
      console.log(`Generated ${result.cardsGenerated} flashcards`);
      // Refresh the page or update local state
      window.location.reload();
    } catch (error) {
      console.error('Failed to generate flashcards:', error);
    } finally {
      setIsGenerating(false);
    }
  };

  return (
    <Dialog>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Generate AI Flashcards</DialogTitle>
        </DialogHeader>

        <div className="space-y-4">
          <div>
            <Label htmlFor="topic">Topic</Label>
            <Input
              id="topic"
              value={topic}
              onChange={(e) => setTopic(e.target.value)}
              placeholder="e.g., React hooks, Python basics, World War II"
            />
          </div>

          <div>
            <Label htmlFor="count">Number of cards</Label>
            <Input
              id="count"
              type="number"
              min={1}
              max={20}
              value={count}
              onChange={(e) => setCount(parseInt(e.target.value))}
            />
          </div>

          <Button
            onClick={handleGenerate}
            disabled={isGenerating || !topic}
          >
            {isGenerating ? 'Generating...' : 'Generate Flashcards'}
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

## Model Selection

Choose appropriate OpenAI models based on use case:

- **`gpt-4o`**: Best quality, most expensive (recommended for flashcard generation)
- **`gpt-4o-mini`**: Faster, cheaper, good quality (cost-effective alternative)
- **`gpt-3.5-turbo`**: Fastest, cheapest (for simple generations)

```typescript
// Use environment variable for model selection
const model = process.env.OPENAI_MODEL || 'gpt-4o';

const { output } = await generateText({
  model: openai(model),
  output: Output.object({
    schema: z.object({
      cards: z.array(
        z.object({
          front: z.string(),
          back: z.string(),
        })
      ),
    }),
  }),
  prompt: 'Generate flashcards...',
});
```

## Error Handling

Handle AI generation errors gracefully:

```typescript
'use server';

import { generateText, Output } from 'ai';
import { openai } from '@ai-sdk/openai';
import { z } from 'zod';

export async function generateFlashcardsAction(input: GenerateFlashcardsInput) {
  const validated = generateFlashcardsSchema.parse(input);

  const { userId } = await auth();
  if (!userId) throw new Error('Unauthorized');

  try {
    const { output } = await generateText({
      model: openai('gpt-4o'),
      output: Output.object({
        schema: z.object({
          cards: z.array(
            z.object({
              front: z.string(),
              back: z.string(),
            })
          ),
        }),
      }),
      prompt: `Generate exactly ${validated.count} flashcards about ${validated.topic}.`,
    });

    // Save to database...
    const savedCards = [];
    for (const card of output.cards) {
      const savedCard = await createCard(userId, validated.deckId, {
        front: card.front,
        back: card.back,
      });
      savedCards.push(savedCard);
    }

    return {
      success: true,
      cardsGenerated: savedCards.length,
      cards: savedCards,
    };
  } catch (error) {
    console.error('AI generation failed:', error);
    
    // Handle specific AI errors
    if (error instanceof Error) {
      if (error.message.includes('API key')) {
        throw new Error('OpenAI API key not configured');
      }
      if (error.message.includes('rate limit')) {
        throw new Error('Rate limit exceeded. Please try again later.');
      }
    }

    throw new Error('Failed to generate flashcards. Please try again.');
  }
}
```

## Best Practices

### 1. Prompt Engineering for Quality Flashcards

Craft prompts that generate educational, well-structured flashcards:

```typescript
const { output } = await generateText({
  model: openai('gpt-4o'),
  output: Output.object({
    schema: z.object({
      cards: z.array(
        z.object({
          front: z.string(),
          back: z.string(),
        })
      ),
    }),
  }),
  prompt: `Generate ${count} high-quality flashcards about ${topic}.

Requirements:
- Each question should be clear, specific, and test understanding
- Each answer should be comprehensive yet concise
- Use simple language appropriate for learning
- Avoid ambiguous questions
- Focus on key concepts and practical knowledge
- Ensure factual accuracy

Format each card with:
- Front: A clear question or prompt
- Back: A detailed but digestible answer`,
});
```

### 2. Type Safety with Zod

Always define strict Zod schemas for type-safe outputs:

```typescript
// ✅ CORRECT - Strict schema with descriptions
const flashcardSchema = z.object({
  cards: z.array(
    z.object({
      front: z.string().min(5).max(500).describe('Question or prompt'),
      back: z.string().min(10).max(1000).describe('Answer or explanation'),
    })
  ).min(1).max(20),
});

// ❌ INCORRECT - Loose schema without validation
const flashcardSchema = z.object({
  cards: z.array(z.any()),
});
```

### 3. Cost Optimization

Optimize costs by using appropriate models and batch operations:

```typescript
// Use cheaper models for simple generations
const simpleGeneration = await generateText({
  model: openai('gpt-4o-mini'), // Cheaper model
  output: Output.object({ schema: flashcardSchema }),
  prompt: 'Generate 5 flashcards about basic addition.',
});

// Use expensive models for complex generations
const complexGeneration = await generateText({
  model: openai('gpt-4o'), // Better model
  output: Output.object({ schema: flashcardSchema }),
  prompt: 'Generate 10 flashcards about quantum computing with detailed explanations.',
});
```

### 4. User Feedback and Regeneration

Allow users to regenerate individual cards:

```typescript
'use server';

import { generateText, Output } from 'ai';
import { openai } from '@ai-sdk/openai';
import { z } from 'zod';
import { updateCard } from '@/db/queries/cards';

const regenerateCardSchema = z.object({
  cardId: z.number(),
  deckId: z.number(),
  topic: z.string(),
  existingFront: z.string().optional(),
});

export async function regenerateCardAction(input: z.infer<typeof regenerateCardSchema>) {
  const validated = regenerateCardSchema.parse(input);

  const { userId } = await auth();
  if (!userId) throw new Error('Unauthorized');

  const { output } = await generateText({
    model: openai('gpt-4o'),
    output: Output.object({
      schema: z.object({
        card: z.object({
          front: z.string(),
          back: z.string(),
        }),
      }),
    }),
    prompt: `Generate a new flashcard about ${validated.topic}.
${validated.existingFront ? `Make it different from this existing card: "${validated.existingFront}"` : ''}
Create a unique, educational question and answer.`,
  });

  // Update the existing card
  await updateCard(userId, validated.cardId, {
    front: output.card.front,
    back: output.card.back,
  });

  return {
    success: true,
    card: output.card,
  };
}
```

## Important Rules Summary

1. ✅ **ALWAYS** use `generateText` with `Output.object()` for structured data
2. ✅ **ALWAYS** define strict Zod schemas for type-safe outputs
3. ✅ **ALWAYS** validate user input before calling AI generation
4. ✅ **ALWAYS** authenticate users in Server Actions before AI calls
5. ✅ **ALWAYS** handle errors gracefully with user-friendly messages
6. ✅ **ALWAYS** use environment variables for API keys and model selection
7. ✅ **ALWAYS** follow the project's Server Action patterns
8. ✅ **ALWAYS** save generated cards to the database using query functions
9. ❌ **NEVER** expose OpenAI API keys to the client
10. ❌ **NEVER** skip input validation before AI generation
11. ❌ **NEVER** trust AI output without Zod validation
12. ❌ **NEVER** generate unlimited cards without rate limiting

## Reference

- Vercel AI SDK Documentation: https://sdk.vercel.ai/docs
- OpenAI Models: https://platform.openai.com/docs/models
- Zod Documentation: https://zod.dev/
- Server Actions: [server-actions-zod-validation.mdc](mdc:.cursor/rules/server-actions-zod-validation.mdc)
- Database Queries: [drizzle-orm.mdc](mdc:.cursor/rules/drizzle-orm.mdc)
