---
alwaysApply: true
description: Server components for data retrieval, server actions for mutations, and Zod validation requirements
---

# Data Operations & Validation Rules

This project follows strict patterns for data operations and validation:

1. **Data retrieval** MUST always be done via **Server Components** calling **query functions** from `db/queries`
2. **Updates/Deletes/Inserts** MUST always be done via **Server Actions** calling **mutation functions** from `db/queries`
3. **All database operations** MUST be abstracted into helper functions in the `db/queries` directory
4. **Data validation** MUST always be done using **Zod**
5. **Server Actions** MUST accept typed parameters (NOT FormData) and validate with Zod
6. **Direct Drizzle queries** are ONLY allowed inside `db/queries` files, NEVER in Server Components or Server Actions

## Rule 1: Data Retrieval via Server Components with Query Functions

### ✅ CORRECT - Server Components Call Query Functions

```typescript
// db/queries/decks.ts - Query Functions
import { db } from '@/db'
import { decksTable } from '@/db/schema'
import { eq } from 'drizzle-orm'

export async function getUserDecks(userId: string) {
  return await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId))
}

// app/decks/page.tsx - Server Component
import { auth } from '@clerk/nextjs/server'
import { redirect } from 'next/navigation'
import { getUserDecks } from '@/db/queries/decks'

export default async function DecksPage() {
  const { userId } = await auth()
  if (!userId) {
    redirect('/sign-in')
  }

  // ✅ Call query function from db/queries
  const decks = await getUserDecks(userId)

  return (
    <div>
      {decks.map((deck) => (
        <div key={deck.id}>{deck.title}</div>
      ))}
    </div>
  )
}
```

### ❌ INCORRECT - Direct Database Queries in Server Components

```typescript
// ❌ DO NOT write direct Drizzle queries in Server Components
// app/decks/page.tsx
import { auth } from '@clerk/nextjs/server'
import { db } from '@/db'
import { decksTable } from '@/db/schema'
import { eq } from 'drizzle-orm'

export default async function DecksPage() {
  const { userId } = await auth()
  if (!userId) {
    redirect('/sign-in')
  }

  // ❌ INCORRECT - Direct database query in component
  const decks = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId))

  return <div>...</div>
}
```

### ❌ INCORRECT - Client-Side Data Fetching

```typescript
// ❌ DO NOT fetch data in Client Components
'use client'

import { useEffect, useState } from 'react'

export default function DecksPage() {
  const [decks, setDecks] = useState([])

  useEffect(() => {
    // ❌ DO NOT fetch data in useEffect or client-side
    fetch('/api/decks')
      .then((res) => res.json())
      .then(setDecks)
  }, [])

  return <div>...</div>
}
```

## Rule 2: Mutations via Server Actions with Mutation Functions

### ✅ CORRECT - Server Actions Call Mutation Functions from db/queries

```typescript
// db/queries/decks.ts - Mutation Functions
import { db } from '@/db'
import { decksTable } from '@/db/schema'
import { eq, and } from 'drizzle-orm'

export async function createDeck(userId: string, data: { title: string; description?: string }) {
  const [newDeck] = await db
    .insert(decksTable)
    .values({
      userId,
      title: data.title,
      description: data.description,
    })
    .returning()

  return newDeck
}

export async function updateDeck(
  userId: string,
  deckId: number,
  data: { title?: string; description?: string }
) {
  // Verify ownership
  const [deck] = await db
    .select()
    .from(decksTable)
    .where(and(eq(decksTable.id, deckId), eq(decksTable.userId, userId)))

  if (!deck) {
    throw new Error('Deck not found or access denied')
  }

  await db
    .update(decksTable)
    .set(data)
    .where(and(eq(decksTable.id, deckId), eq(decksTable.userId, userId)))
}

export async function deleteDeck(userId: string, deckId: number) {
  // Verify ownership
  const [deck] = await db
    .select()
    .from(decksTable)
    .where(and(eq(decksTable.id, deckId), eq(decksTable.userId, userId)))

  if (!deck) {
    throw new Error('Deck not found or access denied')
  }

  await db
    .delete(decksTable)
    .where(and(eq(decksTable.id, deckId), eq(decksTable.userId, userId)))
}

// app/actions/deck-actions.ts - Server Actions
'use server'

import { auth } from '@clerk/nextjs/server'
import { z } from 'zod'
import { createDeck, updateDeck, deleteDeck } from '@/db/queries/decks'

// ✅ Define Zod schema
const createDeckSchema = z.object({
  title: z.string().min(1).max(255),
  description: z.string().optional(),
})

// ✅ Define TypeScript type from Zod schema
type CreateDeckInput = z.infer<typeof createDeckSchema>

// ✅ Server Action: Validate + Authenticate + Call Query Function
export async function createDeckAction(input: CreateDeckInput) {
  // ✅ Validate input with Zod
  const validatedInput = createDeckSchema.parse(input)

  // ✅ Authenticate user
  const { userId } = await auth()
  if (!userId) {
    throw new Error('Unauthorized')
  }

  // ✅ Call mutation function from db/queries
  return await createDeck(userId, validatedInput)
}

// ✅ Update Server Action
const updateDeckSchema = z.object({
  deckId: z.number(),
  title: z.string().min(1).max(255).optional(),
  description: z.string().optional(),
})

type UpdateDeckInput = z.infer<typeof updateDeckSchema>

export async function updateDeckAction(input: UpdateDeckInput) {
  const validatedInput = updateDeckSchema.parse(input)

  const { userId } = await auth()
  if (!userId) {
    throw new Error('Unauthorized')
  }

  // ✅ Call mutation function from db/queries
  await updateDeck(userId, validatedInput.deckId, {
    title: validatedInput.title,
    description: validatedInput.description,
  })
}

// ✅ Delete Server Action
const deleteDeckSchema = z.object({
  deckId: z.number(),
})

type DeleteDeckInput = z.infer<typeof deleteDeckSchema>

export async function deleteDeckAction(input: DeleteDeckInput) {
  const validatedInput = deleteDeckSchema.parse(input)

  const { userId } = await auth()
  if (!userId) {
    throw new Error('Unauthorized')
  }

  // ✅ Call mutation function from db/queries
  await deleteDeck(userId, validatedInput.deckId)
}
```

### ❌ INCORRECT - Direct Database Queries in Server Actions

```typescript
// ❌ DO NOT write direct Drizzle queries in Server Actions
// app/actions/deck-actions.ts
'use server'

import { auth } from '@clerk/nextjs/server'
import { db } from '@/db'
import { decksTable } from '@/db/schema'

export async function createDeckAction(input: { title: string }) {
  const { userId } = await auth()
  if (!userId) throw new Error('Unauthorized')

  // ❌ INCORRECT - Direct database query in Server Action
  const [newDeck] = await db
    .insert(decksTable)
    .values({
      userId,
      title: input.title,
    })
    .returning()

  return newDeck
}
```

### ❌ INCORRECT - Using API Routes or Client-Side Mutations

```typescript
// ❌ DO NOT use API routes for mutations
// app/api/decks/route.ts
export async function POST(request: Request) {
  // ❌ DO NOT create API routes for mutations
}

// ❌ DO NOT mutate data in Client Components
"use client";
export function MyComponent() {
  const handleSubmit = async () => {
    // ❌ DO NOT call database directly from client
    await db.insert(decksTable).values({ ... });
  };
}
```

## Rule 3: Zod Validation Patterns

### ✅ CORRECT - Zod Schema and Type Inference

```typescript
import { z } from 'zod'

// ✅ Define schema
const cardSchema = z.object({
  deckId: z.number(),
  front: z.string().min(1),
  back: z.string().min(1),
})

// ✅ Infer TypeScript type from schema
type CardInput = z.infer<typeof cardSchema>

// ✅ Use in Server Action
export async function createCard(input: CardInput) {
  // ✅ Validate with Zod
  const validatedInput = cardSchema.parse(input)

  // Use validatedInput (fully typed and validated)
  // ...
}
```

### ✅ CORRECT - Advanced Zod Patterns

```typescript
import { z } from 'zod'

// ✅ Complex schema with nested objects
const createDeckWithCardsSchema = z.object({
  title: z.string().min(1).max(255),
  description: z.string().optional(),
  cards: z
    .array(
      z.object({
        front: z.string().min(1),
        back: z.string().min(1),
      })
    )
    .min(1),
})

type CreateDeckWithCardsInput = z.infer<typeof createDeckWithCardsSchema>

// ✅ Schema with refinement
const updateCardSchema = z
  .object({
    cardId: z.number().positive(),
    front: z.string().min(1).optional(),
    back: z.string().min(1).optional(),
  })
  .refine((data) => data.front !== undefined || data.back !== undefined, {
    message: 'At least one field (front or back) must be provided',
  })

type UpdateCardInput = z.infer<typeof updateCardSchema>
```

### ❌ INCORRECT - Missing Validation or Wrong Types

```typescript
// ❌ DO NOT use FormData as type
export async function createDeck(formData: FormData) {
  // ❌ DO NOT use FormData type
}

// ❌ DO NOT skip Zod validation
export async function createDeck(input: { title: string }) {
  // ❌ Missing Zod validation
  await db.insert(decksTable).values(input)
}

// ❌ DO NOT use 'any' or untyped parameters
export async function createDeck(input: any) {
  // ❌ No type safety
}
```

## Rule 4: Server Action Type Requirements

### ✅ CORRECT - Typed Server Actions

```typescript
'use server'

import { z } from 'zod'

// ✅ Define schema
const schema = z.object({
  deckId: z.number(),
  title: z.string().min(1),
})

// ✅ Infer type
type Input = z.infer<typeof schema>

// ✅ Use typed parameter (NOT FormData)
export async function updateDeck(input: Input) {
  const validated = schema.parse(input)
  // ...
}
```

### ❌ INCORRECT - FormData or Untyped Parameters

```typescript
// ❌ DO NOT use FormData as parameter type
export async function updateDeck(formData: FormData) {
  // ❌ FormData is not allowed
}

// ❌ DO NOT use untyped parameters
export async function updateDeck(input: unknown) {
  // ❌ Must have proper TypeScript type
}
```

## Complete Example: Form with Server Action

### ✅ CORRECT - Client Component Calling Server Action

```typescript
// app/components/create-deck-form.tsx
'use client'

import { useState } from 'react'
import { createDeckAction } from '@/app/actions/deck-actions'
import { Button } from '@/components/ui/button'

export function CreateDeckForm() {
  const [title, setTitle] = useState('')

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()

    // ✅ Call Server Action with typed object
    try {
      await createDeckAction({ title })
      setTitle('')
    } catch (error) {
      console.error(error)
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={title}
        onChange={(e) => setTitle(e.target.value)}
        placeholder='Deck title'
      />
      <Button type='submit'>Create Deck</Button>
    </form>
  )
}
```

### ✅ CORRECT - Complete Implementation with Query Function

```typescript
// db/queries/decks.ts - Query Function
import { db } from '@/db'
import { decksTable } from '@/db/schema'

export async function createDeck(userId: string, data: { title: string }) {
  const [newDeck] = await db
    .insert(decksTable)
    .values({
      userId,
      title: data.title,
    })
    .returning()

  return newDeck
}

// app/actions/deck-actions.ts - Server Action
'use server'

import { z } from 'zod'
import { auth } from '@clerk/nextjs/server'
import { createDeck } from '@/db/queries/decks'

const createDeckSchema = z.object({
  title: z.string().min(1).max(255),
})

type CreateDeckInput = z.infer<typeof createDeckSchema>

export async function createDeckAction(input: CreateDeckInput) {
  // ✅ Step 1: Validate with Zod
  const validated = createDeckSchema.parse(input)

  // ✅ Step 2: Authenticate
  const { userId } = await auth()
  if (!userId) throw new Error('Unauthorized')

  // ✅ Step 3: Call query function
  return await createDeck(userId, validated)
}
```

## Error Handling with Zod

### ✅ CORRECT - Handle Validation Errors

```typescript
import { z } from 'zod'

const schema = z.object({
  title: z.string().min(1),
})

type Input = z.infer<typeof schema>

export async function createDeck(input: Input) {
  // ✅ Use safeParse for error handling
  const result = schema.safeParse(input)

  if (!result.success) {
    return {
      error: 'Validation failed',
      details: result.error.errors,
    }
  }

  const validated = result.data
  // ... proceed with validated data
}
```

## Checklist for Every Data Operation

### Data Retrieval (Server Components)

- [ ] ✅ Is data fetched in a Server Component?
- [ ] ✅ Is a query function from `db/queries` being called?
- [ ] ✅ Is authentication verified before calling the query function?
- [ ] ✅ Is the userId passed to the query function?
- [ ] ✅ Are NO direct Drizzle queries in the Server Component?

### Query Functions (db/queries)

- [ ] ✅ Is the function located in the `db/queries` directory?
- [ ] ✅ Does it accept userId as a parameter (for user-scoped queries)?
- [ ] ✅ Are queries filtered by userId?
- [ ] ✅ Is ownership verified (for updates/deletes)?

### Mutations (Server Actions)

- [ ] ✅ Is the function marked with `"use server"`?
- [ ] ✅ Does it accept a typed parameter (NOT FormData)?
- [ ] ✅ Is there a Zod schema defined?
- [ ] ✅ Is the TypeScript type inferred from the Zod schema?
- [ ] ✅ Is input validated with `schema.parse()` or `schema.safeParse()`?
- [ ] ✅ Is authentication verified?
- [ ] ✅ Does it call a mutation function from `db/queries`?
- [ ] ✅ Are NO direct Drizzle queries in the Server Action?

## Important Rules Summary

### Server Components & Server Actions

1. ✅ **ALWAYS** fetch data in Server Components by calling functions from `db/queries`
2. ✅ **ALWAYS** perform mutations via Server Actions by calling functions from `db/queries`
3. ✅ **ALWAYS** define Zod schemas for validation in Server Actions
4. ✅ **ALWAYS** infer TypeScript types from Zod schemas
5. ✅ **ALWAYS** validate Server Action inputs with Zod
6. ✅ **ALWAYS** use typed parameters (NOT FormData)
7. ❌ **NEVER** write direct Drizzle queries in Server Components
8. ❌ **NEVER** write direct Drizzle queries in Server Actions
9. ❌ **NEVER** fetch data in Client Components
10. ❌ **NEVER** mutate data via API routes or client-side
11. ❌ **NEVER** skip Zod validation
12. ❌ **NEVER** use FormData as a parameter type
13. ❌ **NEVER** use `any` or untyped parameters

### Query Functions (db/queries)

1. ✅ **ALWAYS** create query functions in `db/queries` directory
2. ✅ **ALWAYS** accept userId as a parameter for user-scoped operations
3. ✅ **ALWAYS** use Drizzle ORM for database operations
4. ✅ **ALWAYS** verify ownership for updates/deletes
5. ✅ **ALWAYS** filter queries by userId
6. ❌ **NEVER** expose query functions to client-side code
7. ❌ **NEVER** skip ownership verification

## Reference

- Zod Documentation: https://zod.dev/
- Next.js Server Actions: https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations
- Next.js Server Components: https://nextjs.org/docs/app/building-your-application/rendering/server-components
